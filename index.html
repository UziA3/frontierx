<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony App</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #controls {
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    align-items: center;
  }
  #controls button, #controls input[type=range] {
    padding: 6px 12px;
    font-size: 14px;
  }
  #timer {
    font-size: 24px;
    text-align: center;
    margin-bottom: 10px;
  }
  #waveformCanvas {
    background: #fff;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto 20px auto;
  }
  #recordingsList {
    max-width: 800px;
    margin: 0 auto;
  }
  #recordingsList ul {
    list-style: none;
    padding: 0;
  }
  #recordingsList li {
    margin-bottom: 8px;
    border-bottom: 1px solid #ddd;
    padding-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #recordingsList li span.name {
    flex-grow: 1;
  }
  #legend {
    max-width: 800px;
    margin: 0 auto 15px auto;
    font-size: 14px;
    text-align: center;
  }
  #legend span {
    display: inline-block;
    margin: 0 10px;
  }
  .dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    vertical-align: middle;
  }
  .dot.red {
    background: red;
  }
  .dot.green {
    background: green;
  }
  .recording-button {
    margin-left: 10px;
    padding: 4px 8px;
    font-size: 13px;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony App</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
  <button id="toggleWaveformBtn">Hide Waveform</button>
  <label for="pttRange">PTT Compensation (ms): </label>
  <input type="range" id="pttRange" min="0" max="500" value="200" step="10" />
  <span id="pttValue">200</span> ms
  <button id="connectBluetoothBtn">Connect Frontier X (Bluetooth)</button>
</div>

<div id="timer">00:00.00</div>

<canvas id="waveformCanvas" width="800" height="200"></canvas>

<div id="legend">
  <span><span class="dot red"></span> Pulse Peak (R wave)</span>
  <span><span class="dot green"></span> Migraine Throb</span>
</div>

<div id="recordingsList">
  <h2>Recordings</h2>
  <ul id="recordingsUl"></ul>
</div>

<script>
'use strict';

const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const markThrobBtn = document.getElementById('markThrobBtn');
const toggleWaveformBtn = document.getElementById('toggleWaveformBtn');
const pttRange = document.getElementById('pttRange');
const pttValueSpan = document.getElementById('pttValue');
const timerDisplay = document.getElementById('timer');
const recordingsUl = document.getElementById('recordingsUl');
const connectBluetoothBtn = document.getElementById('connectBluetoothBtn');

let recording = false;
let paused = false;
let startTime = 0;
let elapsedPauseTime = 0;
let pauseStart = 0;
let timerInterval = null;

let waveformVisible = true;

const sampleRate = 250; // samples per second (250 Hz)
const displaySeconds = 5;
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

let waveformData = []; // array of {time, value}
let pulsePeaks = []; // array of {time}
let throbs = []; // array of {time, priorPeakIndex}

let recordings = [];

let pttCompensation = Number(pttRange.value); // ms

// ECG simulation parameters
const ecgPeriod = 1000; // ms per beat (60 bpm)

// For timing
const sampleIntervalMs = 1000 / sampleRate; // 4 ms

let sampleTimer = null;
let animationFrameId = null;

// Utils
function formatTime(ms) {
  const totalSeconds = ms / 1000;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2,'0')}:${seconds.toFixed(2).padStart(5,'0')}`;
}

function clearCanvas() {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
}

function enableButtonsDuringRecording(isRecording, isPaused = false) {
  startBtn.disabled = isRecording;
  pauseBtn.disabled = !isRecording || isPaused;
  resumeBtn.disabled = !isRecording || !isPaused;
  stopBtn.disabled = !isRecording;
  markThrobBtn.disabled = !isRecording || isPaused;
  exportCSVButtonsEnabled(recordings.length > 0);
}

function exportCSVButtonsEnabled(enabled) {
  const buttons = recordingsUl.querySelectorAll('button.export-csv');
  buttons.forEach(btn => btn.disabled = !enabled);
}

function findPriorPeakIndex(time) {
  for(let i = pulsePeaks.length - 1; i >= 0; i--) {
    if(pulsePeaks[i].time <= time) return i;
  }
  return -1;
}

// ECG simulation - Gaussian PQRST waveform
function simulateECGSample(t) {
  function gauss(x, mean, sd, amplitude) {
    return amplitude * Math.exp(-((x - mean) ** 2) / (2 * sd * sd));
  }
  const cycleTime = t % ecgPeriod;
  const p = gauss(cycleTime, 100, 15, 0.1);
  const q = gauss(cycleTime, 200, 7, -0.15);
  const r = gauss(cycleTime, 250, 5, 1.0);
  const s = gauss(cycleTime, 280, 5, -0.25);
  const tWave = gauss(cycleTime, 400, 30, 0.35);
  return p + q + r + s + tWave;
}

function updateTimer() {
  if(!recording || paused) return;
  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;
  updateTimerDisplay(elapsed);
}

function updateTimerDisplay(ms) {
  timerDisplay.textContent = formatTime(ms);
}

// Drawing function
function drawCanvas() {
  if(!waveformVisible) {
    clearCanvas();
    return;
  }

  clearCanvas();

  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;

  // Draw waveform
  ctx.beginPath();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;

  let firstPoint = true;
  for(let i = 0; i < waveformData.length; i++) {
    const sample = waveformData[i];
    const relTime = elapsed - sample.time;
    if(relTime < 0 || relTime > displaySeconds * 1000) continue;
    const x = canvasWidth * (1 - relTime / (displaySeconds * 1000));
    const norm = (sample.value + 0.5) / 1.7;
    const y = canvasHeight - norm * canvasHeight;
    if(firstPoint) {
      ctx.moveTo(x, y);
      firstPoint = false;
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();

  // Draw pulse peaks
  ctx.fillStyle = 'red';
  pulsePeaks.forEach(p => {
    const relTime = elapsed - p.time;
    if(relTime < 0 || relTime > displaySeconds * 1000) return;
    const x = canvasWidth * (1 - relTime / (displaySeconds * 1000));

    // Get waveform y at peak time
    let y = canvasHeight/2;
    for(let i = waveformData.length - 1; i >= 0; i--) {
      if(waveformData[i].time <= p.time) {
        const norm = (waveformData[i].value + 0.5)/1.7;
        y = canvasHeight - norm * canvasHeight;
        break;
      }
    }

    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fill();
  });

  // Draw throbs
  ctx.fillStyle = 'green';
  throbs.forEach(t => {
    const relTime = elapsed - t.time;
    if(relTime < 0 || relTime > displaySeconds * 1000) return;
    const x = canvasWidth * (1 - relTime / (displaySeconds * 1000));
    const y = canvasHeight * 0.15;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fill();
  });
}

// Simulation and recording loop
function startRecording() {
  if(recording) return;
  recording = true;
  paused = false;
  startTime = performance.now();
  elapsedPauseTime = 0;
  pulsePeaks = [];
  throbs = [];
  waveformData = [];
  clearCanvas();
  enableButtonsDuringRecording(true);
  updateTimerDisplay(0);

  sampleTimer = setInterval(() => {
    if(!recording || paused) return;
    const now = performance.now();
    const elapsed = now - startTime - elapsedPauseTime;

    // Generate waveform sample at elapsed time
    const sample = simulateECGSample(elapsed);
    waveformData.push({ time: elapsed, value: sample });

    // Keep only last 5 seconds samples
    while(waveformData.length > 0 && (elapsed - waveformData[0].time) > displaySeconds * 1000) {
      waveformData.shift();
    }

    // Add pulse peak if new R peak cycle reached
    const currentCycle = Math.floor(elapsed / ecgPeriod);
    const lastPeakCycle = pulsePeaks.length > 0 ? Math.floor(pulsePeaks[pulsePeaks.length - 1].time / ecgPeriod) : -1;
    if(currentCycle > lastPeakCycle) {
      pulsePeaks.push({ time: currentCycle * ecgPeriod + 250 });
      // Keep pulse peaks only in last 5 seconds
      while(pulsePeaks.length > 0 && (elapsed - pulsePeaks[0].time) > displaySeconds * 1000) {
        pulsePeaks.shift();
      }
    }
  }, sampleIntervalMs);

  // Canvas draw loop runs independently at screen refresh rate
  function drawLoop() {
    if(!recording) {
      clearCanvas();
      return;
    }
    drawCanvas();
    animationFrameId = requestAnimationFrame(drawLoop);
  }
  requestAnimationFrame(drawLoop);

  timerInterval = setInterval(updateTimer, 20);
}

function pauseRecording() {
  if(!recording || paused) return;
  paused = true;
  pauseStart = performance.now();
  enableButtonsDuringRecording(false, true);
  clearInterval(sampleTimer);
  cancelAnimationFrame(animationFrameId);
  clearInterval(timerInterval);
}

function resumeRecording() {
  if(!recording || !paused) return;
  paused = false;
  const pauseDuration = performance.now() - pauseStart;
  elapsedPauseTime += pauseDuration;
  enableButtonsDuringRecording(true);
  sampleTimer = setInterval(() => {
    if(!recording || paused) return;
    const now = performance.now();
    const elapsed = now - startTime - elapsedPauseTime;

    // Generate waveform sample at elapsed time
    const sample = simulateECGSample(elapsed);
    waveformData.push({ time: elapsed, value: sample });

    // Keep only last 5 seconds samples
    while(waveformData.length > 0 && (elapsed - waveformData[0].time) > displaySeconds * 1000) {
      waveformData.shift();
    }

    // Add pulse peak if new R peak cycle reached
    const currentCycle = Math.floor(elapsed / ecgPeriod);
    const lastPeakCycle = pulsePeaks.length > 0 ? Math.floor(pulsePeaks[pulsePeaks.length - 1].time / ecgPeriod) : -1;
    if(currentCycle > lastPeakCycle) {
      pulsePeaks.push({ time: currentCycle * ecgPeriod + 250 });
      // Keep pulse peaks only in last 5 seconds
      while(pulsePeaks.length > 0 && (elapsed - pulsePeaks[0].time) > displaySeconds * 1000) {
        pulsePeaks.shift();
      }
    }
  }, sampleIntervalMs);

  function drawLoop() {
    if(!recording) {
      clearCanvas();
      return;
    }
    drawCanvas();
    animationFrameId = requestAnimationFrame(drawLoop);
  }
  requestAnimationFrame(drawLoop);

  timerInterval = setInterval(updateTimer, 20);
}

function stopRecording() {
  if(!recording) return;
  recording = false;
  paused = false;
  clearInterval(sampleTimer);
  cancelAnimationFrame(animationFrameId);
  clearInterval(timerInterval);

  // Clean old points outside last 5 seconds (just in case)
  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;
  pulsePeaks = pulsePeaks.filter(p => elapsed - p.time <= displaySeconds * 1000);
  throbs = throbs.filter(t => elapsed - t.time <= displaySeconds * 1000);

  throbs.forEach(t => {
    t.priorPeakIndex = findPriorPeakIndex(t.time);
  });

  let recordingName = prompt('Name this recording session:', `Recording_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}`);
  if(!recordingName || recordingName.trim() === '') {
    recordingName = `Recording_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}`;
  }

  const recordingData = {
    name: recordingName,
    pulsePeaks: [...pulsePeaks],
    throbs: [...throbs],
    pttCompensation,
    durationMs: elapsed
  };

  recordings.push(recordingData);
  addRecordingToList(recordingData);

  enableButtonsDuringRecording(false);
  clearCanvas();
  updateTimerDisplay(0);

  pulsePeaks = [];
  throbs = [];
  waveformData = [];
}

function markThrob() {
  if(!recording || paused) return;
  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;
  throbs.push({ time: elapsed, priorPeakIndex: findPriorPeakIndex(elapsed) });
}

function addRecordingToList(rec) {
  const li = document.createElement('li');

  const nameSpan = document.createElement('span');
  nameSpan.textContent = rec.name;
  nameSpan.className = 'name';
  li.appendChild(nameSpan);

  const infoSpan = document.createElement('span');
  infoSpan.textContent = ` Duration: ${(rec.durationMs/1000).toFixed(1)}s, Throbs: ${rec.throbs.length}, Pulses: ${rec.pulsePeaks.length}`;
  infoSpan.style.marginLeft = '8px';
  li.appendChild(infoSpan);

  const exportBtn = document.createElement('button');
  exportBtn.textContent = 'Export CSV';
  exportBtn.className = 'recording-button export-csv';
  exportBtn.addEventListener('click', () => exportCSV(rec));
  li.appendChild(exportBtn);

  recordingsUl.appendChild(li);
  exportCSVButtonsEnabled(true);
}

function exportCSV(rec) {
  if(!rec) return;

  const phases = [];
  const deltas = [];

  for(let i = 0; i < rec.throbs.length; i++) {
    const throb = rec.throbs[i];
    if(throb.priorPeakIndex < 0 || throb.priorPeakIndex >= rec.pulsePeaks.length - 1) continue;
    const priorR = rec.pulsePeaks[throb.priorPeakIndex];
    const nextR = rec.pulsePeaks[throb.priorPeakIndex + 1];
    const delta = throb.time - priorR.time + rec.pttCompensation;
    const interval = nextR.time - priorR.time;
    if(interval <= 0) continue;
    const phase = ((delta % interval) + interval) % interval / interval * 2 * Math.PI;
    phases.push(phase);
    deltas.push(delta);
  }

  const n = phases.length;
  let sumSin = 0, sumCos = 0;
  for(let p of phases) {
    sumSin += Math.sin(p);
    sumCos += Math.cos(p);
  }
  const meanAngle = Math.atan2(sumSin/n, sumCos/n);
  const R = Math.sqrt((sumCos/n)**2 + (sumSin/n)**2);
  const rayleighP = Math.exp(Math.sqrt(1+4*n+4*(n**2 - (n*R)**2)) - (1+2*n));

  const meanDelta = deltas.reduce((a,b)=>a+b,0)/n || 0;
  const stdDelta = Math.sqrt(deltas.reduce((a,b)=>a+(b-meanDelta)**2,0)/n) || 0;

  let csvContent = `Recording Name,${rec.name}\n`;
  csvContent += `Total Throb Count,${rec.throbs.length}\n`;
  csvContent += `Total Pulse Peak Count,${rec.pulsePeaks.length}\n`;
  csvContent += `Mean Pulse Rate (BPM),${(60000 / ecgPeriod).toFixed(2)}\n`;
  csvContent += `Rayleigh R,${R.toFixed(4)}\n`;
  csvContent += `Rayleigh p-value,${rayleighP < 0.001 ? '<0.001' : rayleighP.toFixed(3)}\n`;
  csvContent += `Phase Vector Length (PVL),${R.toFixed(4)}\n`;
  csvContent += `Standard Deviation of Delta (ms),${stdDelta.toFixed(2)}\n`;
  csvContent += `Mean Vector Angle (radians),${meanAngle.toFixed(4)}\n\n`;

  csvContent += `Throb Time (ms),Prior R Peak Time (ms),Delta (ms),BPM at Prior R,Phase (radians)\n`;
  rec.throbs.forEach(t => {
    const i = t.priorPeakIndex;
    if(i < 0 || i >= rec.pulsePeaks.length - 1) return;
    const priorR = rec.pulsePeaks[i];
    const nextR = rec.pulsePeaks[i + 1];
    const delta = t.time - priorR.time + rec.pttCompensation;
    const interval = nextR.time - priorR.time;
    if(interval <= 0) return;
    const phase = ((delta % interval) + interval) % interval / interval * 2 * Math.PI;
    const bpm = 60000 / interval;
    csvContent += `${t.time.toFixed(2)},${priorR.time.toFixed(2)},${delta.toFixed(2)},${bpm.toFixed(2)},${phase.toFixed(4)}\n`;
  });

  csvContent += `\nPulse Peak Times (ms)\n`;
  rec.pulsePeaks.forEach(p => {
    csvContent += `${p.time.toFixed(2)}\n`;
  });

  const blob = new Blob([csvContent], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `${rec.name.replace(/\s+/g,'_')}_data.csv`;
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();

  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Event listeners
startBtn.addEventListener('click', () => {
  startRecording();
});
pauseBtn.addEventListener('click', () => {
  pauseRecording();
});
resumeBtn.addEventListener('click', () => {
  resumeRecording();
});
stopBtn.addEventListener('click', () => {
  stopRecording();
});
markThrobBtn.addEventListener('click', () => {
  markThrob();
});
toggleWaveformBtn.addEventListener('click', () => {
  waveformVisible = !waveformVisible;
  toggleWaveformBtn.textContent = waveformVisible ? 'Hide Waveform' : 'Show Waveform';
  if(!waveformVisible) clearCanvas();
});
pttRange.addEventListener('input', () => {
  pttCompensation = Number(pttRange.value);
  pttValueSpan.textContent = pttCompensation;
});
connectBluetoothBtn.addEventListener('click', () => {
  alert('Bluetooth feature not implemented in this demo.\nUse real device + HTTPS to enable Web Bluetooth.');
});

// Initialize UI state
enableButtonsDuringRecording(false);
</script>
</body>
</html>
