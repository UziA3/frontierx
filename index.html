<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony App</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #controls {
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    align-items: center;
  }
  #controls button, #controls input[type=range] {
    padding: 6px 12px;
    font-size: 14px;
  }
  #timer {
    font-size: 24px;
    text-align: center;
    margin-bottom: 10px;
  }
  #waveformCanvas {
    background: #fff;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto 20px auto;
  }
  #recordingsList {
    max-width: 800px;
    margin: 0 auto;
  }
  #recordingsList ul {
    list-style: none;
    padding: 0;
  }
  #recordingsList li {
    margin-bottom: 8px;
    border-bottom: 1px solid #ddd;
    padding-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #recordingsList li span.name {
    flex-grow: 1;
  }
  #legend {
    max-width: 800px;
    margin: 0 auto 15px auto;
    font-size: 14px;
    text-align: center;
  }
  #legend span {
    display: inline-block;
    margin: 0 10px;
  }
  .dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    vertical-align: middle;
  }
  .dot.red {
    background: red;
  }
  .dot.green {
    background: green;
  }
  .recording-button {
    margin-left: 10px;
    padding: 4px 8px;
    font-size: 13px;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony App</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
  <button id="toggleWaveformBtn">Hide Waveform</button>
  <label for="pttRange">PTT Compensation (ms): </label>
  <input type="range" id="pttRange" min="0" max="500" value="200" step="10" />
  <span id="pttValue">200</span> ms
  <button id="connectBluetoothBtn">Connect Frontier X (Bluetooth)</button>
</div>

<div id="timer">00:00.00</div>

<canvas id="waveformCanvas" width="800" height="200"></canvas>

<div id="legend">
  <span><span class="dot red"></span> Pulse Peak (R wave)</span>
  <span><span class="dot green"></span> Migraine Throb</span>
</div>

<div id="recordingsList">
  <h2>Recordings</h2>
  <ul id="recordingsUl"></ul>
</div>

<script>
'use strict';

const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const markThrobBtn = document.getElementById('markThrobBtn');
const toggleWaveformBtn = document.getElementById('toggleWaveformBtn');
const pttRange = document.getElementById('pttRange');
const pttValueSpan = document.getElementById('pttValue');
const timerDisplay = document.getElementById('timer');
const recordingsUl = document.getElementById('recordingsUl');
const connectBluetoothBtn = document.getElementById('connectBluetoothBtn');

let recording = false;
let paused = false;
let startTime = 0;
let elapsedPauseTime = 0;
let pauseStart = 0;
let timerInterval = null;

let waveformVisible = true;

const sampleRate = 250; // samples per second
const displaySeconds = 5;
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

const dataBufferSize = sampleRate * displaySeconds;
let waveformData = new Array(dataBufferSize).fill(0);
let timeBuffer = new Array(dataBufferSize).fill(0);

let pulsePeaks = []; // { time: ms }
let throbs = []; // { time: ms, priorPeakIndex }

let recordings = [];

let pttCompensation = Number(pttRange.value); // ms

// ECG simulation params
const ecgPeriod = 1000; // ms (60 bpm)
let simulationTime = 0;

let animationFrameId = null;

// Bluetooth placeholders
let bluetoothDevice = null;
let bluetoothCharacteristic = null;

// Utils
function formatTime(ms) {
  const totalSeconds = ms / 1000;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2,'0')}:${seconds.toFixed(2).padStart(5,'0')}`;
}

function clearCanvas() {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
}

function enableButtonsDuringRecording(isRecording, isPaused = false) {
  startBtn.disabled = isRecording;
  pauseBtn.disabled = !isRecording || isPaused;
  resumeBtn.disabled = !isRecording || !isPaused;
  stopBtn.disabled = !isRecording;
  markThrobBtn.disabled = !isRecording || isPaused;
  exportCSVButtonsEnabled(recordings.length > 0);
}

function exportCSVButtonsEnabled(enabled) {
  const buttons = recordingsUl.querySelectorAll('button.export-csv');
  buttons.forEach(btn => btn.disabled = !enabled);
}

function findPriorPeakIndex(time) {
  for(let i = pulsePeaks.length - 1; i >= 0; i--) {
    if(pulsePeaks[i].time <= time) return i;
  }
  return -1;
}

// ECG simulation - Gaussian PQRST
function simulateECGSample(t) {
  function gauss(x, mean, sd, amplitude) {
    return amplitude * Math.exp(-((x - mean) ** 2) / (2 * sd * sd));
  }
  const cycleTime = t % ecgPeriod;
  const p = gauss(cycleTime, 100, 15, 0.1);
  const q = gauss(cycleTime, 200, 7, -0.15);
  const r = gauss(cycleTime, 250, 5, 1.0);
  const s = gauss(cycleTime, 280, 5, -0.25);
  const tWave = gauss(cycleTime, 400, 30, 0.35);
  return p + q + r + s + tWave;
}

function updateTimer() {
  if(!recording || paused) return;
  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;
  updateTimerDisplay(elapsed);
}

function updateTimerDisplay(ms) {
  timerDisplay.textContent = formatTime(ms);
}

// Drawing function
function drawCanvas() {
  if(!waveformVisible) {
    clearCanvas();
    return;
  }

  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  // Draw waveform line
  ctx.beginPath();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  for(let i = 0; i < waveformData.length; i++) {
    const x = (i / dataBufferSize) * canvasWidth;
    const norm = (waveformData[i] + 0.5) / 1.7; // normalize approx -0.5 to 1.2 range
    const y = canvasHeight - norm * canvasHeight;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Draw pulse peaks (red)
  ctx.fillStyle = 'red';
  pulsePeaks.forEach(p => {
    const relTime = simulationTime - p.time;
    if(relTime < 0 || relTime > displaySeconds * 1000) return;
    const x = canvasWidth * (1 - relTime / (displaySeconds * 1000));
    const bufferIndex = Math.floor(dataBufferSize - 1 - (relTime / 1000 * sampleRate));
    if(bufferIndex < 0 || bufferIndex >= waveformData.length) return;
    const sampleVal = waveformData[bufferIndex];
    const norm = (sampleVal + 0.5) / 1.7;
    const y = canvasHeight - norm * canvasHeight;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fill();
  });

  // Draw throbs (green) above waveform
  ctx.fillStyle = 'green';
  throbs.forEach(t => {
    const relTime = simulationTime - t.time;
    if(relTime < 0 || relTime > displaySeconds * 1000) return;
    const x = canvasWidth * (1 - relTime / (displaySeconds * 1000));
    const y = canvasHeight * 0.15;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fill();
  });
}

// Simulation and recording loop
function runSimulation() {
  if(!recording || paused) return;

  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;
  simulationTime = elapsed;

  // Generate waveform sample
  const sample = simulateECGSample(simulationTime);

  waveformData.shift();
  waveformData.push(sample);

  timeBuffer.shift();
  timeBuffer.push(simulationTime);

  // Add pulse peak at each new ECG cycle's R peak (at 250 ms offset)
  const currentCycle = Math.floor(simulationTime / ecgPeriod);
  const lastPeakCycle = pulsePeaks.length > 0 ? Math.floor(pulsePeaks[pulsePeaks.length - 1].time / ecgPeriod) : -1;
  if(currentCycle > lastPeakCycle) {
    pulsePeaks.push({ time: currentCycle * ecgPeriod + 250 });
  }

  drawCanvas();

  animationFrameId = requestAnimationFrame(runSimulation);
}

// Start recording
function startRecording() {
  if(recording) return;
  recording = true;
  paused = false;
  startTime = performance.now();
  elapsedPauseTime = 0;
  simulationTime = 0;
  pulsePeaks = [];
  throbs = [];
  waveformData.fill(0);
  timeBuffer.fill(0);
  clearCanvas();
  enableButtonsDuringRecording(true);
  updateTimerDisplay(0);
  runSimulation();
  timerInterval = setInterval(updateTimer, 20);
}

// Pause recording
function pauseRecording() {
  if(!recording || paused) return;
  paused = true;
  pauseStart = performance.now();
  enableButtonsDuringRecording(false,true);
  cancelAnimationFrame(animationFrameId);
  clearInterval(timerInterval);
}

// Resume recording
function resumeRecording() {
  if(!recording || !paused) return;
  paused = false;
  const pauseDuration = performance.now() - pauseStart;
  elapsedPauseTime += pauseDuration;
  enableButtonsDuringRecording(true);
  runSimulation();
  timerInterval = setInterval(updateTimer, 20);
}

// Stop and save recording
function stopRecording() {
  if(!recording) return;
  recording = false;
  paused = false;
  cancelAnimationFrame(animationFrameId);
  clearInterval(timerInterval);

  let recordingName = prompt('Name this recording session:', `Recording_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}`);
  if(!recordingName || recordingName.trim() === '') {
    recordingName = `Recording_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}`;
  }

  throbs.forEach(t => {
    t.priorPeakIndex = findPriorPeakIndex(t.time);
  });

  const recordingData = {
    name: recordingName,
    pulsePeaks: [...pulsePeaks],
    throbs: [...throbs],
    pttCompensation,
    durationMs: performance.now() - startTime - elapsedPauseTime
  };

  recordings.push(recordingData);
  addRecordingToList(recordingData);

  enableButtonsDuringRecording(false);
  clearCanvas();
  updateTimerDisplay(0);
  pulsePeaks = [];
  throbs = [];
}

// Mark migraine throb
function markThrob() {
  if(!recording || paused) return;
  const now = performance.now() - startTime - elapsedPauseTime;
  throbs.push({ time: now, priorPeakIndex: findPriorPeakIndex(now) });
}

// Add recording entry to list UI
function addRecordingToList(rec) {
  const li = document.createElement('li');

  const nameSpan = document.createElement('span');
  nameSpan.textContent = rec.name;
  nameSpan.className = 'name';
  li.appendChild(nameSpan);

  const infoSpan = document.createElement('span');
  infoSpan.textContent = ` Duration: ${(rec.durationMs/1000).toFixed(1)}s, Throbs: ${rec.throbs.length}, Pulses: ${rec.pulsePeaks.length}`;
  infoSpan.style.marginLeft = '8px';
  li.appendChild(infoSpan);

  const exportBtn = document.createElement('button');
  exportBtn.textContent = 'Export CSV';
  exportBtn.className = 'recording-button export-csv';
  exportBtn.addEventListener('click', () => exportCSV(rec));
  li.appendChild(exportBtn);

  recordingsUl.appendChild(li);
  exportCSVButtonsEnabled(true);
}

// Export CSV function
function exportCSV(rec) {
  if(!rec) return;

  const phases = [];
  const deltas = [];

  for(let i = 0; i < rec.throbs.length; i++) {
    const throb = rec.throbs[i];
    if(throb.priorPeakIndex < 0 || throb.priorPeakIndex >= rec.pulsePeaks.length - 1) continue;
    const priorR = rec.pulsePeaks[throb.priorPeakIndex];
    const nextR = rec.pulsePeaks[throb.priorPeakIndex + 1];
    const delta = throb.time - priorR.time + rec.pttCompensation;
    const interval = nextR.time - priorR.time;
    if(interval <= 0) continue;
    const phase = ((delta % interval) + interval) % interval / interval * 2 * Math.PI;
    phases.push(phase);
    deltas.push(delta);
  }

  const n = phases.length;
  let sumSin = 0, sumCos = 0;
  for(let p of phases) {
    sumSin += Math.sin(p);
    sumCos += Math.cos(p);
  }
  const meanAngle = Math.atan2(sumSin/n, sumCos/n);
  const R = Math.sqrt((sumCos/n)**2 + (sumSin/n)**2);
  const rayleighP = Math.exp(Math.sqrt(1+4*n+4*(n**2 - (n*R)**2)) - (1+2*n));

  const meanDelta = deltas.reduce((a,b)=>a+b,0)/n || 0;
  const stdDelta = Math.sqrt(deltas.reduce((a,b)=>a+(b-meanDelta)**2,0)/n) || 0;

  let csvContent = '';
  csvContent += `Recording Name,${rec.name}\n`;
  csvContent += `Total Throb Count,${rec.throbs.length}\n`;
  csvContent += `Total Pulse Peak Count,${rec.pulsePeaks.length}\n`;
  csvContent += `Mean Pulse Rate (BPM),${(60000/ecgPeriod).toFixed(2)}\n`;
  csvContent += `Rayleigh R,${R.toFixed(4)}\n`;
  csvContent += `Rayleigh p-value,${rayleighP < 0.001 ? '<0.001' : rayleighP.toFixed(3)}\n`;
  csvContent += `Phase Vector Length (PVL),${R.toFixed(4)}\n`;
  csvContent += `Standard Deviation of Delta (ms),${stdDelta.toFixed(2)}\n`;
  csvContent += `Mean Vector Angle (radians),${meanAngle.toFixed(4)}\n\n`;

  csvContent += `Throb Time (ms),Prior R Peak Time (ms),Delta (ms),BPM at Prior R,Phase (radians)\n`;
  for(let i = 0; i < rec.throbs.length; i++) {
    const throb = rec.throbs[i];
    if(throb.priorPeakIndex < 0 || throb.priorPeakIndex >= rec.pulsePeaks.length -1) continue;
    const priorR = rec.pulsePeaks[throb.priorPeakIndex];
    const nextR = rec.pulsePeaks[throb.priorPeakIndex + 1];
    const delta = throb.time - priorR.time + rec.pttCompensation;
    const interval = nextR.time - priorR.time;
    if(interval <= 0) continue;
    const phase = ((delta % interval) + interval) % interval / interval * 2 * Math.PI;
    const bpm = 60000 / ecgPeriod;
    csvContent += `${throb.time.toFixed(
