<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony App</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #controls {
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    align-items: center;
  }
  #controls button, #controls input[type=range] {
    padding: 6px 12px;
    font-size: 14px;
  }
  #timer {
    font-size: 24px;
    text-align: center;
    margin-bottom: 10px;
  }
  #waveformCanvas {
    background: #fff;
    border: 1px solid #ccc;
    display: block;
    margin: 0 auto 20px auto;
  }
  #recordingsList {
    max-width: 800px;
    margin: 0 auto;
  }
  #recordingsList ul {
    list-style: none;
    padding: 0;
  }
  #recordingsList li {
    margin-bottom: 8px;
    border-bottom: 1px solid #ddd;
    padding-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #recordingsList li span.name {
    flex-grow: 1;
  }
  #legend {
    max-width: 800px;
    margin: 0 auto 15px auto;
    font-size: 14px;
    text-align: center;
  }
  #legend span {
    display: inline-block;
    margin: 0 10px;
  }
  .dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    vertical-align: middle;
  }
  .dot.red {
    background: red;
  }
  .dot.green {
    background: green;
  }
  .recording-button {
    margin-left: 10px;
    padding: 4px 8px;
    font-size: 13px;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony App</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
  <button id="toggleWaveformBtn">Hide Waveform</button>
  <label for="pttRange">PTT Compensation (ms): </label>
  <input type="range" id="pttRange" min="0" max="500" value="200" step="10" />
  <span id="pttValue">200</span> ms
  <button id="connectBluetoothBtn">Connect Frontier X (Bluetooth)</button>
</div>

<div id="timer">00:00.00</div>

<canvas id="waveformCanvas" width="800" height="200"></canvas>

<div id="legend">
  <span><span class="dot red"></span> Pulse Peak (R wave)</span>
  <span><span class="dot green"></span> Migraine Throb</span>
</div>

<div id="recordingsList">
  <h2>Recordings</h2>
  <ul id="recordingsUl"></ul>
</div>

<script>
'use strict';

const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const markThrobBtn = document.getElementById('markThrobBtn');
const toggleWaveformBtn = document.getElementById('toggleWaveformBtn');
const pttRange = document.getElementById('pttRange');
const pttValueSpan = document.getElementById('pttValue');
const timerDisplay = document.getElementById('timer');
const recordingsUl = document.getElementById('recordingsUl');
const connectBluetoothBtn = document.getElementById('connectBluetoothBtn');

let recording = false;
let paused = false;
let startTime = 0;
let elapsedPauseTime = 0;
let pauseStart = 0;
let timerInterval = null;

let waveformVisible = true;

const sampleRate = 250; // samples per second
const displaySeconds = 5;
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

const dataBufferSize = sampleRate * displaySeconds;
let waveformData = new Array(dataBufferSize).fill(0);
let timeBuffer = new Array(dataBufferSize).fill(0);

let pulsePeaks = []; // { time: ms }
let throbs = []; // { time: ms, priorPeakIndex }

let recordings = [];

let pttCompensation = Number(pttRange.value); // ms

// For ECG simulation
const ecgPeriod = 1000; // ms (60 bpm)
let simulationTime = 0;
let lastSimulatedRTime = -Infinity;

let animationFrameId = null;

// Bluetooth placeholders
let bluetoothDevice = null;
let bluetoothCharacteristic = null;

// Utility: format ms to mm:ss.ss
function formatTime(ms) {
  const totalSeconds = ms / 1000;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2,'0')}:${seconds.toFixed(2).padStart(5,'0')}`;
}

// Start recording session
function startRecording() {
  if(recording) return;
  recording = true;
  paused = false;
  startTime = performance.now();
  elapsedPauseTime = 0;
  simulationTime = 0;
  lastSimulatedRTime = -Infinity;
  pulsePeaks = [];
  throbs = [];
  waveformData.fill(0);
  timeBuffer.fill(0);
  clearCanvas();
  enableButtonsDuringRecording(true);
  updateTimerDisplay(0);
  runSimulation();
  timerInterval = setInterval(updateTimer, 20);
}

// Pause recording
function pauseRecording() {
  if(!recording || paused) return;
  paused = true;
  pauseStart = performance.now();
  enableButtonsDuringRecording(false,true);
  cancelAnimationFrame(animationFrameId);
  clearInterval(timerInterval);
}

// Resume recording
function resumeRecording() {
  if(!recording || !paused) return;
  paused = false;
  const pauseDuration = performance.now() - pauseStart;
  elapsedPauseTime += pauseDuration;
  enableButtonsDuringRecording(true);
  runSimulation();
  timerInterval = setInterval(updateTimer, 20);
}

// Stop recording and save
function stopRecording() {
  if(!recording) return;
  recording = false;
  paused = false;
  cancelAnimationFrame(animationFrameId);
  clearInterval(timerInterval);

  let recordingName = prompt('Name this recording session:', `Recording_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}`);
  if(!recordingName || recordingName.trim() === '') {
    recordingName = `Recording_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}`;
  }

  // Link each throb to its prior peak index
  throbs.forEach(t => {
    t.priorPeakIndex = findPriorPeakIndex(t.time);
  });

  const recordingData = {
    name: recordingName,
    pulsePeaks: [...pulsePeaks],
    throbs: [...throbs],
    pttCompensation,
    durationMs: performance.now() - startTime - elapsedPauseTime
  };
  recordings.push(recordingData);
  addRecordingToList(recordingData);
  enableButtonsDuringRecording(false);
  clearCanvas();
  updateTimerDisplay(0);

  // Reset buffers
  pulsePeaks = [];
  throbs = [];
}

// Mark a migraine throb
function markThrob() {
  if(!recording || paused) return;
  const now = performance.now() - startTime - elapsedPauseTime;
  throbs.push({time: now, priorPeakIndex: findPriorPeakIndex(now)});
}

// Find the index of pulse peak immediately before given time
function findPriorPeakIndex(time) {
  for(let i = pulsePeaks.length - 1; i >= 0; i--) {
    if(pulsePeaks[i].time <= time) return i;
  }
  return -1;
}

// Timer update
function updateTimer() {
  if(!recording || paused) return;
  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;
  updateTimerDisplay(elapsed);
}

// Update timer display text
function updateTimerDisplay(ms) {
  timerDisplay.textContent = formatTime(ms);
}

// Enable/disable buttons based on recording state
function enableButtonsDuringRecording(isRecording, isPaused = false) {
  startBtn.disabled = isRecording;
  pauseBtn.disabled = !isRecording || isPaused;
  resumeBtn.disabled = !isRecording || !isPaused;
  stopBtn.disabled = !isRecording;
  markThrobBtn.disabled = !isRecording || isPaused;
  exportCSVButtonsEnabled(recordings.length > 0);
}

// Enable/disable all export buttons in recordings list
function exportCSVButtonsEnabled(enabled) {
  const buttons = recordingsUl.querySelectorAll('button.export-csv');
  buttons.forEach(btn => btn.disabled = !enabled);
}

// ECG simulation function: Gaussian pulses for PQRST
function simulateECGSample(t) {
  // t in ms mod ecgPeriod

  function gauss(x, mean, sd, amplitude) {
    return amplitude * Math.exp(-((x - mean) ** 2) / (2 * sd * sd));
  }

  const cycleTime = t % ecgPeriod;

  const p = gauss(cycleTime, 100, 15, 0.1);
  const q = gauss(cycleTime, 200, 7, -0.15);
  const r = gauss(cycleTime, 250, 5, 1.0);
  const s = gauss(cycleTime, 280, 5, -0.25);
  const tWave = gauss(cycleTime, 400, 30, 0.35);

  return p + q + r + s + tWave;
}

// Run simulation and draw
function runSimulation() {
  if(!recording || paused) return;

  const now = performance.now();
  const elapsed = now - startTime - elapsedPauseTime;
  simulationTime = elapsed;

  // Generate sample for current time
  const sample = simulateECGSample(simulationTime);

  // Shift waveform data buffer and time buffer
  waveformData.shift();
  waveformData.push(sample);
  timeBuffer.shift();
  timeBuffer.push(simulationTime);

  // Detect R peak by simulation timing directly (R at 250ms in cycle)
  // Register pulse peak exactly when simulationTime crosses 250 + n*ecgPeriod
  const prevCycle = Math.floor((simulationTime - 1) / ecgPeriod);
  const currCycle = Math.floor(simulationTime / ecgPeriod);
  if(currCycle > prevCycle) {
    // New cycle started, R peak at cycle start + 250 ms
    const peakTime = currCycle * ecgPeriod + 250;
    // Add peak if it hasn't been added yet (allow some leeway)
    if(pulsePeaks.length === 0 || peakTime > pulsePeaks[pulsePeaks.length - 1].time + 200) {
      pulsePeaks.push({time: peakTime});
    }
  }

  drawCanvas();

  animationFrameId = requestAnimationFrame(runSimulation);
}

// Draw canvas waveform and markers aligned to simulationTime
function drawCanvas() {
  if(!waveformVisible) {
    clearCanvas();
    return;
  }

  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  // Draw waveform line
  ctx.beginPath();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  for(let i = 0; i < waveformData.length; i++) {
    const x = (i / dataBufferSize) * canvasWidth;
    const norm = (waveformData[i] + 0.5) / 1.7; // Normalize approx -0.5 to 1.2
    const y = canvasHeight - norm * canvasHeight;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Draw pulse peaks (red) on waveform
  ctx.fillStyle = 'red';
  pulsePeaks.forEach(p => {
    const relTime = simulationTime - p.time;
    if(relTime < 0 || relTime > displaySeconds * 1000) return;
    const x = canvasWidth * (1 - relTime / (displaySeconds * 1000));
    // Find waveform value near this time to place dot on waveform line
    const bufferIndex = Math.floor(dataBufferSize - 1 - (relTime / 1000 * sampleRate));
    if(bufferIndex < 0 || bufferIndex >= waveformData.length) return;
    const sampleVal = waveformData[bufferIndex];
    const norm = (sampleVal + 0.5) / 1.7;
    const y = canvasHeight - norm * canvasHeight;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fill();
  });

  // Draw migraine throbs (green) above waveform line (fixed y)
  ctx.fillStyle = 'green';
  throbs.forEach(t => {
    const relTime = simulationTime - t.time;
    if(relTime < 0 || relTime > displaySeconds * 1000) return;
    const x = canvasWidth * (1 - relTime / (displaySeconds * 1000));
    const y = canvasHeight * 0.15;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fill();
  });
}

// Clear canvas
function clearCanvas() {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
}

// Add recording to list UI with export button
function addRecordingToList(rec) {
  const li = document.createElement('li');

  // Name span
  const nameSpan = document.createElement('span');
  nameSpan.textContent = rec.name;
  nameSpan.className = 'name';
  li.appendChild(nameSpan);

  // Info text
  const infoSpan = document.createElement('span');
  infoSpan.textContent = ` Duration: ${(rec.durationMs/1000).toFixed(1)}s, Throbs: ${rec.throbs.length}, Pulses: ${rec.pulsePeaks.length}`;
  infoSpan.style.marginLeft = '8px';
  li.appendChild(infoSpan);

  // Export CSV button
  const exportBtn = document.createElement('button');
  exportBtn.textContent = 'Export CSV';
  exportBtn.className = 'recording-button export-csv';
  exportBtn.addEventListener('click', () => exportCSV(rec));
  li.appendChild(exportBtn);

  recordingsUl.appendChild(li);
  exportCSVButtonsEnabled(true);
}

// Export CSV for given recording
function exportCSV(rec) {
  if(!rec) return;

  // Calculate phase and delta arrays for throbs
  const phases = [];
  const deltas = [];

  for(let i = 0; i < rec.throbs.length; i++) {
    const throb = rec.throbs[i];
    if(throb.priorPeakIndex < 0 || throb.priorPeakIndex >= rec.pulsePeaks.length -1) continue;
    const priorR = rec.pulsePeaks[throb.priorPeakIndex];
    const nextR = rec.pulsePeaks[throb.priorPeakIndex + 1];
    const delta = throb.time - priorR.time + rec.pttCompensation;
    const interval = nextR.time - priorR.time;
    if(interval <= 0) continue;
    const phase = ((delta % interval) + interval) % interval / interval * 2 * Math.PI;
    phases.push(phase);
    deltas.push(delta);
  }

  const n = phases.length;
  // Compute Rayleigh R and mean angle
  let sumSin = 0, sumCos = 0;
  for(let p of phases) {
    sumSin += Math.sin(p);
    sumCos += Math.cos(p);
  }
  const meanAngle = Math.atan2(sumSin/n, sumCos/n);
  const R = Math.sqrt((sumCos/n)**2 + (sumSin/n)**2);
  // Approximate Rayleigh p-value
  const rayleighP = Math.exp(Math.sqrt(1+4*n+4*(n**2 - (n*R)**2)) - (1+2*n));

  const meanDelta = deltas.reduce((a,b)=>a+b,0)/n || 0;
  const stdDelta = Math.sqrt(deltas.reduce((a,b)=>a+(b-meanDelta)**2,0)/n) || 0;

  let csvContent = '';
  csvContent += `Recording Name,${rec.name}\n`;
  csvContent += `Total Throb Count,${rec.throbs.length}\n`;
  csvContent += `Total Pulse Peak Count,${rec.pulsePeaks.length}\n`;
  csvContent += `Mean Pulse Rate (BPM),${(60000/ecgPeriod).toFixed(2)}\n`;
  csvContent += `Rayleigh R,${R.toFixed(4)}\n`;
  csvContent += `Rayleigh p-value,${rayleighP < 0.001 ? '<0.001' : rayleighP.toFixed(3)}\n`;
  csvContent += `Phase Vector Length (PVL),${R.toFixed(4)}\n`;
  csvContent += `Standard Deviation of Delta (ms),${stdDelta.toFixed(2)}\n`;
  csvContent += `Mean Vector Angle (radians),${meanAngle.toFixed(4)}\n\n`;

  csvContent += `Throb Time (ms),Prior R Peak Time (ms),Delta (ms),BPM at Prior R,Phase (radians)\n`;
  for(let i = 0; i < rec.throbs.length; i++) {
    const throb = rec.throbs[i];
    if(throb.priorPeakIndex < 0 || throb.priorPeakIndex >= rec.pulsePeaks.length -1) continue;
    const priorR = rec.pulsePeaks[throb.priorPeakIndex];
    const nextR = rec.pulsePeaks[throb.priorPeakIndex + 1];
    const delta = throb.time - priorR.time + rec.pttCompensation;
    const interval = nextR.time - priorR.time;
    if(interval <= 0) continue;
    const phase = ((delta % interval) + interval) % interval / interval * 2 * Math.PI;
    const bpm = 60000 / ecgPeriod;
    csvContent += `${throb.time.toFixed(2)},${priorR.time.toFixed(2)},${delta.toFixed(2)},${bpm.toFixed(2)},${phase.toFixed(4)}\n`;
  }

  csvContent += `\nPulse Peak Timestamps (ms)\n`;
  for(let p of rec.pulsePeaks) {
    csvContent += `${p.time.toFixed(2)}\n`;
  }

  // Download CSV
  const blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${rec.name.replace(/\s+/g,'_')}_migraine_throb_sync.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Toggle waveform display
function toggleWaveform() {
  waveformVisible = !waveformVisible;
  toggleWaveformBtn.textContent = waveformVisible ? 'Hide Waveform' : 'Show Waveform';
  if(!waveformVisible) clearCanvas();
  else drawCanvas();
}

pttRange.addEventListener('input', e => {
  pttCompensation = Number(e.target.value);
  pttValueSpan.textContent = pttCompensation;
});

startBtn.addEventListener('click', startRecording);
pauseBtn.addEventListener('click', pauseRecording);
resumeBtn.addEventListener('click', resumeRecording);
stopBtn.addEventListener('click', stopRecording);
markThrobBtn.addEventListener('click', markThrob);
toggleWaveformBtn.addEventListener('click', toggleWaveform);

// Bluetooth connect (Frontier X filtered by name prefix)
connectBluetoothBtn.addEventListener('click', async () => {
  if(!navigator.bluetooth) {
    alert('Web Bluetooth API not supported in this browser.');
    return;
  }
  try {
    bluetoothDevice = await navigator.bluetooth.requestDevice({
      filters: [{namePrefix: 'Frontier'}],
      optionalServices: ['heart_rate']
    });
    bluetoothDevice.addEventListener('gattserverdisconnected', () => {
      alert('Bluetooth device disconnected');
      bluetoothDevice = null;
      bluetoothCharacteristic = null;
    });
    const server = await bluetoothDevice.gatt.connect();
    const service = await server.getPrimaryService('heart_rate');
    bluetoothCharacteristic = await service.getCharacteristic('heart_rate_measurement');
    await bluetoothCharacteristic.startNotifications();
    bluetoothCharacteristic.addEventListener('characteristicvaluechanged', handleBluetoothData);
    alert(`Connected to ${bluetoothDevice.name}`);
  } catch(e) {
    alert('Bluetooth connection failed: ' + e);
  }
});

function handleBluetoothData(event) {
  if(!recording || paused) return;

  const value = event.target.value;
  const flags = value.getUint8(0);
  const hrFormat = flags & 0x01;
  let heartRate = 0;
  if(hrFormat === 0) {
    heartRate = value.getUint8(1);
  } else {
    heartRate = value.getUint16(1, true);
  }

  // For demo: mark pulse peak at current timestamp for Bluetooth data
  const now = performance.now() - startTime - elapsedPauseTime;
  pulsePeaks.push({time: now});
  drawCanvas();
}

</script>
</body>
</html>
